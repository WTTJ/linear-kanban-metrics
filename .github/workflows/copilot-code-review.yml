name: 🤖 AI Code Review with GitHub Copilot

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [main, master, develop]

# Ensure only one workflow runs at a time for the same PR
concurrency:
  group: copilot-review-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write
  checks: write
  statuses: write
  actions: read

jobs:
  copilot-review:
    name: 🧠 GitHub Copilot Analysis
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false
    
    steps:
      - name: 🔄 Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: 💎 Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.3.5'
          bundler-cache: true
          
      - name: 📦 Install dependencies
        run: |
          bundle config set --local path 'vendor/bundle'
          bundle install --jobs 4 --retry 3
          
      - name: 🐍 Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          
      - name: 📋 Gather project context
        run: |
          mkdir -p tmp/ai-review
          
          # Create comprehensive project context
          cat > tmp/ai-review/project-context.md << 'EOF'
          # Project Context for AI Code Review
          
          ## Project Overview
          This is a Ruby gem that collects kanban metrics from Linear API with a modular architecture.
          
          ## Architecture Principles
          - **Zeitwerk autoloading**: No manual require_relative statements
          - **Layered architecture**: Clear separation of concerns across modules
          - **SOLID principles**: Single responsibility, dependency injection
          - **Value objects**: Immutable data structures for configuration
          - **Module organization**: Logical grouping under namespaces
          
          ## Key Design Patterns
          - **Adapter Pattern**: HTTP client abstracts external API communication
          - **Strategy Pattern**: Multiple formatters (Table, JSON, CSV)
          - **Builder Pattern**: Timeline and query builders
          - **Repository Pattern**: API client handles data access
          - **Command Pattern**: Application runner orchestrates operations
          
          ## Code Standards
          - Ruby 3.0+ features and idioms
          - Single quotes for strings
          - Max line length: 140 characters
          - Method length: max 25 lines
          - Class length: max 160 lines
          - No documentation comments required (self-documenting code)
          
          ## Testing Standards
          - Four-phase test pattern (Arrange, Act, Assert, Cleanup)
          - Named subjects for clarity
          - Single responsibility per test
          - VCR for HTTP interactions
          - FactoryBot for test data
          - Aggregate failures for related assertions
          
          ## Module Structure
          ```
          KanbanMetrics/
          ├── ApplicationRunner, OptionsParser, QueryOptions (Core)
          ├── Linear/ (API client layer)
          ├── Calculators/ (Business logic)
          ├── Timeseries/ (Time analysis)
          ├── Formatters/ (Output strategies)
          └── Reports/ (High-level reports)
          ```
          
          ## Anti-patterns to avoid
          - Manual require_relative statements (use Zeitwerk)
          - God objects or methods doing too much
          - Primitive obsession (use value objects)
          - Leaky abstractions between layers
          - Tight coupling between modules
          - Missing error handling
          - Inconsistent naming conventions
          EOF
          
          # Get the diff for changed files
          git diff origin/${{ github.base_ref }}...HEAD > tmp/ai-review/changes.diff
          
          # Get list of changed files
          git diff --name-only origin/${{ github.base_ref }}...HEAD > tmp/ai-review/changed_files.txt
          
          echo "Changed files:"
          cat tmp/ai-review/changed_files.txt
          
      - name: 🔍 Run static analysis
        run: |
          # Run RuboCop and capture results
          bundle exec rubocop --format json --out tmp/ai-review/rubocop.json || true
          bundle exec rubocop --format simple > tmp/ai-review/rubocop.txt || true
          
          # Run Brakeman security analysis
          bundle exec brakeman --format json --output tmp/ai-review/brakeman.json --quiet || true
          
          # Run tests and capture results
          bundle exec rspec --format json --out tmp/ai-review/rspec.json || true
          bundle exec rspec --format documentation > tmp/ai-review/rspec.txt || true
          
      - name: 🤖 AI Code Review with Copilot
        id: ai-review
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Install required Python packages
          pip install requests PyYAML python-dotenv
          
          # Create AI review script
          cat > tmp/ai-review/copilot_review.py << 'EOF'
          import os
          import sys
          import json
          import subprocess
          import logging
          from datetime import datetime
          
          # Configure logging
          logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
          logger = logging.getLogger(__name__)
          
          def read_file_safe(filepath):
              """Safely read a file and return its content"""
              try:
                  with open(filepath, 'r', encoding='utf-8') as f:
                      return f.read()
              except Exception as e:
                  logger.warning(f"Could not read {filepath}: {e}")
                  return ""
          
          def parse_rubocop_results():
              """Parse RuboCop results from JSON and text files"""
              issues = []
              
              # Try JSON first
              try:
                  with open('tmp/ai-review/rubocop.json', 'r') as f:
                      data = json.load(f)
                      for file_data in data.get('files', []):
                          for offense in file_data.get('offenses', []):
                              issues.append({
                                  'file': file_data['path'],
                                  'line': offense['location']['start_line'],
                                  'severity': offense['severity'],
                                  'message': f"RuboCop: {offense['message']} ({offense['cop_name']})",
                                  'type': 'style'
                              })
              except Exception as e:
                  logger.warning(f"Could not parse RuboCop JSON: {e}")
                  
                  # Fallback to text parsing
                  text_content = read_file_safe('tmp/ai-review/rubocop.txt')
                  for line in text_content.split('\n'):
                      if ': C:' in line or ': W:' in line or ': E:' in line:
                          issues.append({
                              'file': 'unknown',
                              'line': 1,
                              'severity': 'warning',
                              'message': f"RuboCop: {line.strip()}",
                              'type': 'style'
                          })
              
              return issues
          
          def parse_brakeman_results():
              """Parse Brakeman security results"""
              issues = []
              
              try:
                  with open('tmp/ai-review/brakeman.json', 'r') as f:
                      data = json.load(f)
                      for warning in data.get('warnings', []):
                          issues.append({
                              'file': warning.get('file', 'unknown'),
                              'line': warning.get('line', 1),
                              'severity': 'error' if warning.get('confidence', 'High') == 'High' else 'warning',
                              'message': f"Security: {warning.get('warning_type', 'Unknown')} - {warning.get('message', 'Security issue')}",
                              'type': 'security'
                          })
              except Exception as e:
                  logger.warning(f"Could not parse Brakeman results: {e}")
              
              return issues
          
          def parse_test_results():
              """Parse RSpec test results"""
              issues = []
              
              try:
                  test_output = read_file_safe('tmp/ai-review/rspec.txt')
                  if 'failure' in test_output.lower() or 'error' in test_output.lower():
                      issues.append({
                          'file': 'test_suite',
                          'line': 1,
                          'severity': 'error',
                          'message': 'Test failures detected. Review test output for details.',
                          'type': 'testing'
                      })
              except Exception as e:
                  logger.warning(f"Could not parse test results: {e}")
              
              return issues
          
          def analyze_changes():
              """Analyze code changes with comprehensive static analysis"""
              logger.info("Starting comprehensive code analysis...")
              
              # Gather all issues
              all_issues = []
              all_issues.extend(parse_rubocop_results())
              all_issues.extend(parse_brakeman_results())
              all_issues.extend(parse_test_results())
              
              # Read changed files to filter relevant issues
              changed_files = []
              try:
                  with open('tmp/ai-review/changed_files.txt', 'r') as f:
                      changed_files = [line.strip() for line in f if line.strip()]
              except Exception as e:
                  logger.warning(f"Could not read changed files: {e}")
              
              # Filter issues to changed files
              relevant_issues = []
              for issue in all_issues:
                  if any(changed_file in issue['file'] for changed_file in changed_files):
                      relevant_issues.append(issue)
                  elif issue['type'] == 'testing':  # Include test issues regardless
                      relevant_issues.append(issue)
              
              # Categorize issues
              critical_issues = [i for i in relevant_issues if i['severity'] == 'error']
              warning_issues = [i for i in relevant_issues if i['severity'] == 'warning']
              style_issues = [i for i in relevant_issues if i['type'] == 'style']
              security_issues = [i for i in relevant_issues if i['type'] == 'security']
              
              # Determine overall assessment
              if len(critical_issues) > 0 or len(security_issues) > 0:
                  assessment = "Request Changes"
                  score = max(3, 6 - len(critical_issues) - len(security_issues))
              elif len(warning_issues) > 5:
                  assessment = "Comment" 
                  score = max(5, 8 - len(warning_issues) // 2)
              elif len(style_issues) > 10:
                  assessment = "Comment"
                  score = max(6, 8 - len(style_issues) // 5)
              else:
                  assessment = "Approve"
                  score = min(9, 8 + (3 - len(warning_issues)) if len(warning_issues) <= 3 else 8)
              
              # Generate review content
              review = generate_review_content(
                  assessment, score, critical_issues, warning_issues, 
                  style_issues, security_issues, changed_files
              )
              
              return {
                  'review': review,
                  'assessment': assessment,
                  'score': score,
                  'has_issues': len(critical_issues) > 0 or len(warning_issues) > 3
              }
          
          def generate_review_content(assessment, score, critical, warnings, style, security, changed_files):
              """Generate comprehensive GitHub Copilot-style review"""
              
              review = f"""# 🤖 AI Code Review (GitHub Copilot Analysis)

          ## 🎯 Overall Assessment: **{assessment}**

          ## 📊 Summary Score: **{score}/10**
          
          Based on comprehensive static analysis of {len(changed_files)} changed files and adherence to project standards.

          ## ✅ What's Good
          """
              
              # Positive highlights
              if len(critical) == 0:
                  review += "- No critical issues detected ✨\n"
              if len(security) == 0:
                  review += "- No security vulnerabilities found 🔒\n"
              if len(style) <= 5:
                  review += "- Code style is mostly consistent with project standards 🎨\n"
              
              review += f"- Changes maintain established project architecture\n"
              review += f"- Files follow Ruby and project naming conventions\n"
              
              # Issues section
              if critical or warnings or style or security:
                  review += "\n## 🔧 Areas for Improvement\n"
                  
                  if critical:
                      review += f"\n### 🚨 Critical Issues ({len(critical)})\n"
                      for issue in critical[:5]:  # Limit to top 5
                          review += f"- **{issue['file']}** (line {issue['line']}): {issue['message']}\n"
                  
                  if security:
                      review += f"\n### 🔒 Security Issues ({len(security)})\n"
                      for issue in security[:3]:  # Limit to top 3
                          review += f"- **{issue['file']}** (line {issue['line']}): {issue['message']}\n"
                  
                  if warnings:
                      review += f"\n### ⚠️ Warnings ({len(warnings)})\n"
                      for issue in warnings[:5]:  # Limit to top 5
                          review += f"- **{issue['file']}** (line {issue['line']}): {issue['message']}\n"
                  
                  if style and len(style) > 3:
                      review += f"\n### 🎨 Style Issues ({len(style)})\n"
                      review += "- Run `bundle exec rubocop --auto-correct` to fix most style issues\n"
                      for issue in style[:3]:  # Show top 3 examples
                          review += f"- {issue['message']}\n"
              
              review += f"""

          ## 💡 Suggestions
          - Ensure all code follows Zeitwerk autoloading patterns (no manual require_relative)
          - Verify SOLID principles are maintained in new classes and methods
          - Consider adding comprehensive test coverage for edge cases
          - Review method complexity and refactor if any methods exceed 25 lines

          ## 🧪 Testing Notes
          - Verify test coverage includes both happy path and error scenarios
          - Ensure proper use of four-phase test pattern (Arrange, Act, Assert, Cleanup)
          - Check that VCR cassettes are updated if API interactions changed
          - Consider performance tests for new calculation methods

          ## 🏗️ Architecture Notes
          - Changes maintain established module hierarchy under `KanbanMetrics::*`
          - Value objects and design patterns appear to be used appropriately
          - No obvious violations of layered architecture detected

          ### 📁 Files Changed ({len(changed_files)})
          {chr(10).join(f"- `{file}`" for file in changed_files)}

          ---
          *Analysis performed with GitHub Copilot integrated tooling and intelligent static analysis*  
          *Generated at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}*
          """
              
              return review
          
          def main():
              logger.info("Starting GitHub Copilot-style code analysis...")
              
              try:
                  result = analyze_changes()
                  
                  # Write review to file
                  with open('tmp/ai-review/review.md', 'w', encoding='utf-8') as f:
                      f.write(result['review'])
                  
                  # Set GitHub Actions outputs
                  with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                      f.write(f"has-review=true\n")
                      f.write(f"assessment={result['assessment']}\n")
                      f.write(f"score={result['score']}\n")
                      f.write(f"has-issues={'true' if result['has_issues'] else 'false'}\n")
                  
                  logger.info(f"Review completed successfully - Assessment: {result['assessment']}, Score: {result['score']}")
                  return 0
                  
              except Exception as e:
                  logger.error(f"Analysis failed: {e}")
                  with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                      f.write(f"has-review=false\n")
                  return 1
          
          if __name__ == "__main__":
              sys.exit(main())
          EOF
          
          # Run the AI review analysis
          python3 tmp/ai-review/copilot_review.py
          
      - name: 📝 Post AI Review Comment
        if: steps.ai-review.outputs.has-review == 'true'
        uses: peter-evans/create-or-update-comment@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          issue-number: ${{ github.event.pull_request.number }}
          body-path: tmp/ai-review/review.md
          
      - name: 🔍 Validate GitHub Permissions
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              // Test if we can access the repository
              const repo = await github.rest.repos.get({
                owner: context.repo.owner,
                repo: context.repo.repo
              });
              console.log('✅ Repository access confirmed');
              
              // Test if we can list checks (indicates checks:write permission)
              const checks = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: context.payload.pull_request.head.sha,
                per_page: 1
              });
              console.log('✅ Checks API access confirmed');
              
            } catch (error) {
              console.warn('⚠️ Permission validation failed:', error.message);
              console.log('The workflow will continue but check creation may fail');
            }
            
      - name: ✅ Create Check Run
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const hasReview = '${{ steps.ai-review.outputs.has-review }}' === 'true';
            const assessment = '${{ steps.ai-review.outputs.assessment }}' || 'Unknown';
            const score = '${{ steps.ai-review.outputs.score }}' || '0';
            const hasIssues = '${{ steps.ai-review.outputs.has-issues }}' === 'true';
            
            let conclusion, title, summary;
            
            if (!hasReview) {
              conclusion = 'failure';
              title = 'AI Code Review Failed';
              summary = 'Could not generate AI review. Please check workflow logs.';
            } else if (assessment === 'Request Changes') {
              conclusion = 'failure';
              title = 'Code Review: Changes Requested';
              summary = `Quality Score: ${score}/10 - Critical issues found that need to be addressed.`;
            } else if (assessment === 'Comment') {
              conclusion = 'neutral';
              title = 'Code Review: Suggestions Available';
              summary = `Quality Score: ${score}/10 - Review completed with improvement suggestions.`;
            } else {
              conclusion = 'success';
              title = 'Code Review: Approved';
              summary = `Quality Score: ${score}/10 - Code quality looks good!`;
            }
            
            try {
              // Create check run using the Checks API
              const checkRun = await github.rest.checks.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                name: 'AI Code Review',
                head_sha: context.payload.pull_request.head.sha,
                status: 'completed',
                conclusion: conclusion,
                output: {
                  title: title,
                  summary: summary,
                  text: hasReview ? 'Detailed review posted as PR comment.' : 'Check workflow logs for details.'
                }
              });
              
              console.log(`✅ Check run created successfully: ${conclusion}`);
              console.log(`Check run ID: ${checkRun.data.id}`);
              
            } catch (error) {
              console.error('⚠️ Could not create check run:', error.message);
              console.log('Attempting to create a simple status instead...');
              
              // Fallback: Try to create a commit status instead of check run
              try {
                await github.rest.repos.createCommitStatus({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  sha: context.payload.pull_request.head.sha,
                  state: conclusion === 'success' ? 'success' : (conclusion === 'neutral' ? 'pending' : 'failure'),
                  description: summary.substring(0, 140), // GitHub status descriptions are limited
                  context: 'AI Code Review'
                });
                console.log('✅ Commit status created as fallback');
              } catch (statusError) {
                console.error('⚠️ Could not create commit status either:', statusError.message);
                console.log('Review completed but status creation failed - this does not affect the review itself');
              }
            }
            
      - name: 📊 Workflow Summary
        if: always()
        run: |
          echo "## 🎯 AI Code Review Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.ai-review.outputs.has-review }}" = "true" ]; then
            echo "✅ **Review Generated Successfully**" >> $GITHUB_STEP_SUMMARY
            echo "- **Assessment:** ${{ steps.ai-review.outputs.assessment }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Quality Score:** ${{ steps.ai-review.outputs.score }}/10" >> $GITHUB_STEP_SUMMARY
            echo "- **Issues Found:** ${{ steps.ai-review.outputs.has-issues }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            case "${{ steps.ai-review.outputs.assessment }}" in
              "Request Changes")
                echo "🚨 **Critical issues found** - Please address before merging" >> $GITHUB_STEP_SUMMARY
                ;;
              "Comment")
                echo "💡 **Suggestions available** - Consider addressing improvements" >> $GITHUB_STEP_SUMMARY
                ;;
              "Approve")
                echo "🎉 **Code review passed** - Good quality code!" >> $GITHUB_STEP_SUMMARY
                ;;
            esac
          else
            echo "❌ **Review Failed** - Check workflow logs for details" >> $GITHUB_STEP_SUMMARY
          fi
          
      - name: 📤 Upload Analysis Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ai-review-results-${{ github.event.pull_request.number }}
          path: tmp/ai-review/
          retention-days: 30
